import {
  Commands,
  Inputs,
  Transaction,
  UpgradePolicy,
  createObjectMethods,
  createPure,
  getClient,
  getPureBcsSchema,
  isArgument,
  isTransaction,
  namedPackagesPlugin,
  normalizedTypeToMoveTypeSignature
} from "./chunk-NPTSXXV4.js";
import {
  TransactionDataBuilder,
  bigint,
  normalizeStructTag,
  normalizeSuiAddress,
  object,
  parse,
  promiseWithResolvers,
  string,
  suiBcs,
  toBase64
} from "./chunk-FKTNSZW2.js";
import "./chunk-EQCVQC35.js";

// node_modules/@mysten/sui/dist/esm/transactions/ObjectCache.js
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _caches;
var _cache;
var _onEffects;
var AsyncCache = class {
  async getObject(id) {
    const [owned, shared] = await Promise.all([
      this.get("OwnedObject", id),
      this.get("SharedOrImmutableObject", id)
    ]);
    return owned ?? shared ?? null;
  }
  async getObjects(ids) {
    return Promise.all([...ids.map((id) => this.getObject(id))]);
  }
  async addObject(object2) {
    if (object2.owner) {
      await this.set("OwnedObject", object2.objectId, object2);
    } else {
      await this.set("SharedOrImmutableObject", object2.objectId, object2);
    }
    return object2;
  }
  async addObjects(objects) {
    await Promise.all(objects.map(async (object2) => this.addObject(object2)));
  }
  async deleteObject(id) {
    await Promise.all([this.delete("OwnedObject", id), this.delete("SharedOrImmutableObject", id)]);
  }
  async deleteObjects(ids) {
    await Promise.all(ids.map((id) => this.deleteObject(id)));
  }
  async getMoveFunctionDefinition(ref) {
    const functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;
    return this.get("MoveFunction", functionName);
  }
  async addMoveFunctionDefinition(functionEntry) {
    const pkg = normalizeSuiAddress(functionEntry.package);
    const functionName = `${pkg}::${functionEntry.module}::${functionEntry.function}`;
    const entry = {
      ...functionEntry,
      package: pkg
    };
    await this.set("MoveFunction", functionName, entry);
    return entry;
  }
  async deleteMoveFunctionDefinition(ref) {
    const functionName = `${normalizeSuiAddress(ref.package)}::${ref.module}::${ref.function}`;
    await this.delete("MoveFunction", functionName);
  }
  async getCustom(key) {
    return this.get("Custom", key);
  }
  async setCustom(key, value) {
    return this.set("Custom", key, value);
  }
  async deleteCustom(key) {
    return this.delete("Custom", key);
  }
};
var InMemoryCache = class extends AsyncCache {
  constructor() {
    super(...arguments);
    __privateAdd(this, _caches, {
      OwnedObject: /* @__PURE__ */ new Map(),
      SharedOrImmutableObject: /* @__PURE__ */ new Map(),
      MoveFunction: /* @__PURE__ */ new Map(),
      Custom: /* @__PURE__ */ new Map()
    });
  }
  async get(type, key) {
    return __privateGet(this, _caches)[type].get(key) ?? null;
  }
  async set(type, key, value) {
    __privateGet(this, _caches)[type].set(key, value);
  }
  async delete(type, key) {
    __privateGet(this, _caches)[type].delete(key);
  }
  async clear(type) {
    if (type) {
      __privateGet(this, _caches)[type].clear();
    } else {
      for (const cache of Object.values(__privateGet(this, _caches))) {
        cache.clear();
      }
    }
  }
};
_caches = /* @__PURE__ */ new WeakMap();
var ObjectCache = class {
  constructor({ cache = new InMemoryCache(), onEffects }) {
    __privateAdd(this, _cache);
    __privateAdd(this, _onEffects);
    __privateSet(this, _cache, cache);
    __privateSet(this, _onEffects, onEffects);
  }
  asPlugin() {
    return async (transactionData, _options, next) => {
      const unresolvedObjects = transactionData.inputs.filter((input) => input.UnresolvedObject).map((input) => input.UnresolvedObject.objectId);
      const cached = (await __privateGet(this, _cache).getObjects(unresolvedObjects)).filter(
        (obj) => obj !== null
      );
      const byId = new Map(cached.map((obj) => [obj.objectId, obj]));
      for (const input of transactionData.inputs) {
        if (!input.UnresolvedObject) {
          continue;
        }
        const cached2 = byId.get(input.UnresolvedObject.objectId);
        if (!cached2) {
          continue;
        }
        if (cached2.initialSharedVersion && !input.UnresolvedObject.initialSharedVersion) {
          input.UnresolvedObject.initialSharedVersion = cached2.initialSharedVersion;
        } else {
          if (cached2.version && !input.UnresolvedObject.version) {
            input.UnresolvedObject.version = cached2.version;
          }
          if (cached2.digest && !input.UnresolvedObject.digest) {
            input.UnresolvedObject.digest = cached2.digest;
          }
        }
      }
      await Promise.all(
        transactionData.commands.map(async (commands) => {
          if (commands.MoveCall) {
            const def = await this.getMoveFunctionDefinition({
              package: commands.MoveCall.package,
              module: commands.MoveCall.module,
              function: commands.MoveCall.function
            });
            if (def) {
              commands.MoveCall._argumentTypes = def.parameters;
            }
          }
        })
      );
      await next();
      await Promise.all(
        transactionData.commands.map(async (commands) => {
          var _a;
          if ((_a = commands.MoveCall) == null ? void 0 : _a._argumentTypes) {
            await __privateGet(this, _cache).addMoveFunctionDefinition({
              package: commands.MoveCall.package,
              module: commands.MoveCall.module,
              function: commands.MoveCall.function,
              parameters: commands.MoveCall._argumentTypes
            });
          }
        })
      );
    };
  }
  async clear() {
    await __privateGet(this, _cache).clear();
  }
  async getMoveFunctionDefinition(ref) {
    return __privateGet(this, _cache).getMoveFunctionDefinition(ref);
  }
  async getObjects(ids) {
    return __privateGet(this, _cache).getObjects(ids);
  }
  async deleteObjects(ids) {
    return __privateGet(this, _cache).deleteObjects(ids);
  }
  async clearOwnedObjects() {
    await __privateGet(this, _cache).clear("OwnedObject");
  }
  async clearCustom() {
    await __privateGet(this, _cache).clear("Custom");
  }
  async getCustom(key) {
    return __privateGet(this, _cache).getCustom(key);
  }
  async setCustom(key, value) {
    return __privateGet(this, _cache).setCustom(key, value);
  }
  async deleteCustom(key) {
    return __privateGet(this, _cache).deleteCustom(key);
  }
  async applyEffects(effects) {
    var _a;
    if (!effects.V2) {
      throw new Error(`Unsupported transaction effects version ${effects.$kind}`);
    }
    const { lamportVersion, changedObjects } = effects.V2;
    const deletedIds = [];
    const addedObjects = [];
    changedObjects.forEach(([id, change]) => {
      var _a2;
      if (change.outputState.NotExist) {
        deletedIds.push(id);
      } else if (change.outputState.ObjectWrite) {
        const [digest, owner] = change.outputState.ObjectWrite;
        addedObjects.push({
          objectId: id,
          digest,
          version: lamportVersion,
          owner: owner.AddressOwner ?? owner.ObjectOwner ?? null,
          initialSharedVersion: ((_a2 = owner.Shared) == null ? void 0 : _a2.initialSharedVersion) ?? null
        });
      }
    });
    await Promise.all([
      __privateGet(this, _cache).addObjects(addedObjects),
      __privateGet(this, _cache).deleteObjects(deletedIds),
      (_a = __privateGet(this, _onEffects)) == null ? void 0 : _a.call(this, effects)
    ]);
  }
};
_cache = /* @__PURE__ */ new WeakMap();
_onEffects = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/sui/dist/esm/transactions/executor/caching.js
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _client;
var _lastDigest;
var CachingTransactionExecutor = class {
  constructor({
    client,
    ...options
  }) {
    __privateAdd2(this, _client);
    __privateAdd2(this, _lastDigest, null);
    __privateSet2(this, _client, client);
    this.cache = new ObjectCache(options);
  }
  /**
   * Clears all Owned objects
   * Immutable objects, Shared objects, and Move function definitions will be preserved
   */
  async reset() {
    await Promise.all([
      this.cache.clearOwnedObjects(),
      this.cache.clearCustom(),
      this.waitForLastTransaction()
    ]);
  }
  async buildTransaction({
    transaction,
    ...options
  }) {
    transaction.addBuildPlugin(this.cache.asPlugin());
    return transaction.build({
      client: __privateGet2(this, _client),
      ...options
    });
  }
  async executeTransaction({
    transaction,
    options,
    ...input
  }) {
    const bytes = isTransaction(transaction) ? await this.buildTransaction({ transaction }) : transaction;
    const results = await __privateGet2(this, _client).executeTransactionBlock({
      ...input,
      transactionBlock: bytes,
      options: {
        ...options,
        showRawEffects: true
      }
    });
    if (results.rawEffects) {
      const effects = suiBcs.TransactionEffects.parse(Uint8Array.from(results.rawEffects));
      await this.applyEffects(effects);
    }
    return results;
  }
  async signAndExecuteTransaction({
    options,
    transaction,
    ...input
  }) {
    transaction.setSenderIfNotSet(input.signer.toSuiAddress());
    const bytes = await this.buildTransaction({ transaction });
    const { signature } = await input.signer.signTransaction(bytes);
    const results = await this.executeTransaction({
      transaction: bytes,
      signature,
      options
    });
    return results;
  }
  async applyEffects(effects) {
    var _a;
    __privateSet2(this, _lastDigest, ((_a = effects.V2) == null ? void 0 : _a.transactionDigest) ?? null);
    await this.cache.applyEffects(effects);
  }
  async waitForLastTransaction() {
    if (__privateGet2(this, _lastDigest)) {
      await __privateGet2(this, _client).waitForTransaction({ digest: __privateGet2(this, _lastDigest) });
      __privateSet2(this, _lastDigest, null);
    }
  }
};
_client = /* @__PURE__ */ new WeakMap();
_lastDigest = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/sui/dist/esm/transactions/executor/queue.js
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var _queue;
var _queue2;
var SerialQueue = class {
  constructor() {
    __privateAdd3(this, _queue, []);
  }
  async runTask(task) {
    return new Promise((resolve, reject) => {
      __privateGet3(this, _queue).push(() => {
        task().finally(() => {
          __privateGet3(this, _queue).shift();
          if (__privateGet3(this, _queue).length > 0) {
            __privateGet3(this, _queue)[0]();
          }
        }).then(resolve, reject);
      });
      if (__privateGet3(this, _queue).length === 1) {
        __privateGet3(this, _queue)[0]();
      }
    });
  }
};
_queue = /* @__PURE__ */ new WeakMap();
var ParallelQueue = class {
  constructor(maxTasks) {
    __privateAdd3(this, _queue2, []);
    this.activeTasks = 0;
    this.maxTasks = maxTasks;
  }
  runTask(task) {
    return new Promise((resolve, reject) => {
      if (this.activeTasks < this.maxTasks) {
        this.activeTasks++;
        task().finally(() => {
          if (__privateGet3(this, _queue2).length > 0) {
            __privateGet3(this, _queue2).shift()();
          } else {
            this.activeTasks--;
          }
        }).then(resolve, reject);
      } else {
        __privateGet3(this, _queue2).push(() => {
          task().finally(() => {
            if (__privateGet3(this, _queue2).length > 0) {
              __privateGet3(this, _queue2).shift()();
            } else {
              this.activeTasks--;
            }
          }).then(resolve, reject);
        });
      }
    });
  }
};
_queue2 = /* @__PURE__ */ new WeakMap();

// node_modules/@mysten/sui/dist/esm/transactions/executor/serial.js
var __typeError4 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck4 = (obj, member, msg) => member.has(obj) || __typeError4("Cannot " + msg);
var __privateGet4 = (obj, member, getter) => (__accessCheck4(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd4 = (obj, member, value) => member.has(obj) ? __typeError4("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet3 = (obj, member, value, setter) => (__accessCheck4(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var _queue3;
var _signer;
var _cache2;
var _defaultGasBudget;
var _cacheGasCoin;
var _buildTransaction;
var SerialTransactionExecutor = class {
  constructor({
    signer,
    defaultGasBudget = 50000000n,
    ...options
  }) {
    __privateAdd4(this, _queue3, new SerialQueue());
    __privateAdd4(this, _signer);
    __privateAdd4(this, _cache2);
    __privateAdd4(this, _defaultGasBudget);
    __privateAdd4(this, _cacheGasCoin, async (effects) => {
      if (!effects.V2) {
        return;
      }
      const gasCoin = getGasCoinFromEffects(effects).ref;
      if (gasCoin) {
        __privateGet4(this, _cache2).cache.setCustom("gasCoin", gasCoin);
      } else {
        __privateGet4(this, _cache2).cache.deleteCustom("gasCoin");
      }
    });
    __privateAdd4(this, _buildTransaction, async (transaction) => {
      const gasCoin = await __privateGet4(this, _cache2).cache.getCustom("gasCoin");
      const copy = Transaction.from(transaction);
      if (gasCoin) {
        copy.setGasPayment([gasCoin]);
      }
      copy.setGasBudgetIfNotSet(__privateGet4(this, _defaultGasBudget));
      copy.setSenderIfNotSet(__privateGet4(this, _signer).toSuiAddress());
      return __privateGet4(this, _cache2).buildTransaction({ transaction: copy });
    });
    __privateSet3(this, _signer, signer);
    __privateSet3(this, _defaultGasBudget, defaultGasBudget);
    __privateSet3(this, _cache2, new CachingTransactionExecutor({
      client: options.client,
      cache: options.cache,
      onEffects: (effects) => __privateGet4(this, _cacheGasCoin).call(this, effects)
    }));
  }
  async applyEffects(effects) {
    return __privateGet4(this, _cache2).applyEffects(effects);
  }
  async buildTransaction(transaction) {
    return __privateGet4(this, _queue3).runTask(() => __privateGet4(this, _buildTransaction).call(this, transaction));
  }
  resetCache() {
    return __privateGet4(this, _cache2).reset();
  }
  waitForLastTransaction() {
    return __privateGet4(this, _cache2).waitForLastTransaction();
  }
  executeTransaction(transaction, options, additionalSignatures = []) {
    return __privateGet4(this, _queue3).runTask(async () => {
      const bytes = isTransaction(transaction) ? await __privateGet4(this, _buildTransaction).call(this, transaction) : transaction;
      const { signature } = await __privateGet4(this, _signer).signTransaction(bytes);
      const results = await __privateGet4(this, _cache2).executeTransaction({
        signature: [signature, ...additionalSignatures],
        transaction: bytes,
        options
      }).catch(async (error) => {
        await this.resetCache();
        throw error;
      });
      const effectsBytes = Uint8Array.from(results.rawEffects);
      return {
        digest: results.digest,
        effects: toBase64(effectsBytes),
        data: results
      };
    });
  }
};
_queue3 = /* @__PURE__ */ new WeakMap();
_signer = /* @__PURE__ */ new WeakMap();
_cache2 = /* @__PURE__ */ new WeakMap();
_defaultGasBudget = /* @__PURE__ */ new WeakMap();
_cacheGasCoin = /* @__PURE__ */ new WeakMap();
_buildTransaction = /* @__PURE__ */ new WeakMap();
function getGasCoinFromEffects(effects) {
  if (!effects.V2) {
    throw new Error("Unexpected effects version");
  }
  const gasObjectChange = effects.V2.changedObjects[effects.V2.gasObjectIndex];
  if (!gasObjectChange) {
    throw new Error("Gas object not found in effects");
  }
  const [objectId, { outputState }] = gasObjectChange;
  if (!outputState.ObjectWrite) {
    throw new Error("Unexpected gas object state");
  }
  const [digest, owner] = outputState.ObjectWrite;
  return {
    ref: {
      objectId,
      digest,
      version: effects.V2.lamportVersion
    },
    owner: owner.AddressOwner || owner.ObjectOwner
  };
}

// node_modules/@mysten/sui/dist/esm/transactions/executor/parallel.js
var __typeError5 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck5 = (obj, member, msg) => member.has(obj) || __typeError5("Cannot " + msg);
var __privateGet5 = (obj, member, getter) => (__accessCheck5(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd5 = (obj, member, value) => member.has(obj) ? __typeError5("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet4 = (obj, member, value, setter) => (__accessCheck5(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck5(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet4(obj, member, value, setter);
  },
  get _() {
    return __privateGet5(obj, member, getter);
  }
});
var _signer2;
var _client2;
var _coinBatchSize;
var _initialCoinBalance;
var _minimumCoinBalance;
var _epochBoundaryWindow;
var _defaultGasBudget2;
var _maxPoolSize;
var _sourceCoins;
var _coinPool;
var _cache3;
var _objectIdQueues;
var _buildQueue;
var _executeQueue;
var _lastDigest2;
var _cacheLock;
var _pendingTransactions;
var _gasPrice;
var _ParallelTransactionExecutor_instances;
var getUsedObjects_fn;
var execute_fn;
var updateCache_fn;
var waitForLastDigest_fn;
var getGasCoin_fn;
var getGasPrice_fn;
var refillCoinPool_fn;
var PARALLEL_EXECUTOR_DEFAULTS = {
  coinBatchSize: 20,
  initialCoinBalance: 200000000n,
  minimumCoinBalance: 50000000n,
  maxPoolSize: 50,
  epochBoundaryWindow: 1e3
};
var ParallelTransactionExecutor = class {
  constructor(options) {
    __privateAdd5(this, _ParallelTransactionExecutor_instances);
    __privateAdd5(this, _signer2);
    __privateAdd5(this, _client2);
    __privateAdd5(this, _coinBatchSize);
    __privateAdd5(this, _initialCoinBalance);
    __privateAdd5(this, _minimumCoinBalance);
    __privateAdd5(this, _epochBoundaryWindow);
    __privateAdd5(this, _defaultGasBudget2);
    __privateAdd5(this, _maxPoolSize);
    __privateAdd5(this, _sourceCoins);
    __privateAdd5(this, _coinPool, []);
    __privateAdd5(this, _cache3);
    __privateAdd5(this, _objectIdQueues, /* @__PURE__ */ new Map());
    __privateAdd5(this, _buildQueue, new SerialQueue());
    __privateAdd5(this, _executeQueue);
    __privateAdd5(this, _lastDigest2, null);
    __privateAdd5(this, _cacheLock, null);
    __privateAdd5(this, _pendingTransactions, 0);
    __privateAdd5(this, _gasPrice, null);
    __privateSet4(this, _signer2, options.signer);
    __privateSet4(this, _client2, options.client);
    __privateSet4(this, _coinBatchSize, options.coinBatchSize ?? PARALLEL_EXECUTOR_DEFAULTS.coinBatchSize);
    __privateSet4(this, _initialCoinBalance, options.initialCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.initialCoinBalance);
    __privateSet4(this, _minimumCoinBalance, options.minimumCoinBalance ?? PARALLEL_EXECUTOR_DEFAULTS.minimumCoinBalance);
    __privateSet4(this, _defaultGasBudget2, options.defaultGasBudget ?? __privateGet5(this, _minimumCoinBalance));
    __privateSet4(this, _epochBoundaryWindow, options.epochBoundaryWindow ?? PARALLEL_EXECUTOR_DEFAULTS.epochBoundaryWindow);
    __privateSet4(this, _maxPoolSize, options.maxPoolSize ?? PARALLEL_EXECUTOR_DEFAULTS.maxPoolSize);
    __privateSet4(this, _cache3, new CachingTransactionExecutor({
      client: options.client,
      cache: options.cache
    }));
    __privateSet4(this, _executeQueue, new ParallelQueue(__privateGet5(this, _maxPoolSize)));
    __privateSet4(this, _sourceCoins, options.sourceCoins ? new Map(options.sourceCoins.map((id) => [id, null])) : null);
  }
  resetCache() {
    __privateSet4(this, _gasPrice, null);
    return __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateGet5(this, _cache3).reset());
  }
  async waitForLastTransaction() {
    await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, () => __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this));
  }
  async executeTransaction(transaction, options, additionalSignatures = []) {
    const { promise, resolve, reject } = promiseWithResolvers();
    const usedObjects = await __privateMethod(this, _ParallelTransactionExecutor_instances, getUsedObjects_fn).call(this, transaction);
    const execute = () => {
      __privateGet5(this, _executeQueue).runTask(() => {
        const promise2 = __privateMethod(this, _ParallelTransactionExecutor_instances, execute_fn).call(this, transaction, usedObjects, options, additionalSignatures);
        return promise2.then(resolve, reject);
      });
    };
    const conflicts = /* @__PURE__ */ new Set();
    usedObjects.forEach((objectId) => {
      const queue = __privateGet5(this, _objectIdQueues).get(objectId);
      if (queue) {
        conflicts.add(objectId);
        __privateGet5(this, _objectIdQueues).get(objectId).push(() => {
          conflicts.delete(objectId);
          if (conflicts.size === 0) {
            execute();
          }
        });
      } else {
        __privateGet5(this, _objectIdQueues).set(objectId, []);
      }
    });
    if (conflicts.size === 0) {
      execute();
    }
    return promise;
  }
};
_signer2 = /* @__PURE__ */ new WeakMap();
_client2 = /* @__PURE__ */ new WeakMap();
_coinBatchSize = /* @__PURE__ */ new WeakMap();
_initialCoinBalance = /* @__PURE__ */ new WeakMap();
_minimumCoinBalance = /* @__PURE__ */ new WeakMap();
_epochBoundaryWindow = /* @__PURE__ */ new WeakMap();
_defaultGasBudget2 = /* @__PURE__ */ new WeakMap();
_maxPoolSize = /* @__PURE__ */ new WeakMap();
_sourceCoins = /* @__PURE__ */ new WeakMap();
_coinPool = /* @__PURE__ */ new WeakMap();
_cache3 = /* @__PURE__ */ new WeakMap();
_objectIdQueues = /* @__PURE__ */ new WeakMap();
_buildQueue = /* @__PURE__ */ new WeakMap();
_executeQueue = /* @__PURE__ */ new WeakMap();
_lastDigest2 = /* @__PURE__ */ new WeakMap();
_cacheLock = /* @__PURE__ */ new WeakMap();
_pendingTransactions = /* @__PURE__ */ new WeakMap();
_gasPrice = /* @__PURE__ */ new WeakMap();
_ParallelTransactionExecutor_instances = /* @__PURE__ */ new WeakSet();
getUsedObjects_fn = async function(transaction) {
  const usedObjects = /* @__PURE__ */ new Set();
  let serialized = false;
  transaction.addSerializationPlugin(async (blockData, _options, next) => {
    await next();
    if (serialized) {
      return;
    }
    serialized = true;
    blockData.inputs.forEach((input) => {
      var _a, _b, _c, _d, _e;
      if ((_b = (_a = input.Object) == null ? void 0 : _a.ImmOrOwnedObject) == null ? void 0 : _b.objectId) {
        usedObjects.add(input.Object.ImmOrOwnedObject.objectId);
      } else if ((_d = (_c = input.Object) == null ? void 0 : _c.Receiving) == null ? void 0 : _d.objectId) {
        usedObjects.add(input.Object.Receiving.objectId);
      } else if (((_e = input.UnresolvedObject) == null ? void 0 : _e.objectId) && !input.UnresolvedObject.initialSharedVersion) {
        usedObjects.add(input.UnresolvedObject.objectId);
      }
    });
  });
  await transaction.prepareForSerialization({ client: __privateGet5(this, _client2) });
  return usedObjects;
};
execute_fn = async function(transaction, usedObjects, options, additionalSignatures = []) {
  var _a;
  let gasCoin;
  try {
    transaction.setSenderIfNotSet(__privateGet5(this, _signer2).toSuiAddress());
    await __privateGet5(this, _buildQueue).runTask(async () => {
      const data = transaction.getData();
      if (!data.gasData.price) {
        transaction.setGasPrice(await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this));
      }
      transaction.setGasBudgetIfNotSet(__privateGet5(this, _defaultGasBudget2));
      await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this);
      gasCoin = await __privateMethod(this, _ParallelTransactionExecutor_instances, getGasCoin_fn).call(this);
      __privateWrapper(this, _pendingTransactions)._++;
      transaction.setGasPayment([
        {
          objectId: gasCoin.id,
          version: gasCoin.version,
          digest: gasCoin.digest
        }
      ]);
      await __privateGet5(this, _cache3).buildTransaction({ transaction, onlyTransactionKind: true });
    });
    const bytes = await transaction.build({ client: __privateGet5(this, _client2) });
    const { signature } = await __privateGet5(this, _signer2).signTransaction(bytes);
    const results = await __privateGet5(this, _cache3).executeTransaction({
      transaction: bytes,
      signature: [signature, ...additionalSignatures],
      options: {
        ...options,
        showEffects: true
      }
    });
    const effectsBytes = Uint8Array.from(results.rawEffects);
    const effects = suiBcs.TransactionEffects.parse(effectsBytes);
    const gasResult = getGasCoinFromEffects(effects);
    const gasUsed = (_a = effects.V2) == null ? void 0 : _a.gasUsed;
    if (gasCoin && gasUsed && gasResult.owner === __privateGet5(this, _signer2).toSuiAddress()) {
      const totalUsed = BigInt(gasUsed.computationCost) + BigInt(gasUsed.storageCost) + BigInt(gasUsed.storageCost) - BigInt(gasUsed.storageRebate);
      let usesGasCoin = false;
      new TransactionDataBuilder(transaction.getData()).mapArguments((arg) => {
        if (arg.$kind === "GasCoin") {
          usesGasCoin = true;
        }
        return arg;
      });
      if (!usesGasCoin && gasCoin.balance >= __privateGet5(this, _minimumCoinBalance)) {
        __privateGet5(this, _coinPool).push({
          id: gasResult.ref.objectId,
          version: gasResult.ref.version,
          digest: gasResult.ref.digest,
          balance: gasCoin.balance - totalUsed
        });
      } else {
        if (!__privateGet5(this, _sourceCoins)) {
          __privateSet4(this, _sourceCoins, /* @__PURE__ */ new Map());
        }
        __privateGet5(this, _sourceCoins).set(gasResult.ref.objectId, gasResult.ref);
      }
    }
    __privateSet4(this, _lastDigest2, results.digest);
    return {
      digest: results.digest,
      effects: toBase64(effectsBytes),
      data: results
    };
  } catch (error) {
    if (gasCoin) {
      if (!__privateGet5(this, _sourceCoins)) {
        __privateSet4(this, _sourceCoins, /* @__PURE__ */ new Map());
      }
      __privateGet5(this, _sourceCoins).set(gasCoin.id, null);
    }
    await __privateMethod(this, _ParallelTransactionExecutor_instances, updateCache_fn).call(this, async () => {
      await Promise.all([
        __privateGet5(this, _cache3).cache.deleteObjects([...usedObjects]),
        __privateMethod(this, _ParallelTransactionExecutor_instances, waitForLastDigest_fn).call(this)
      ]);
    });
    throw error;
  } finally {
    usedObjects.forEach((objectId) => {
      const queue = __privateGet5(this, _objectIdQueues).get(objectId);
      if (queue && queue.length > 0) {
        queue.shift()();
      } else if (queue) {
        __privateGet5(this, _objectIdQueues).delete(objectId);
      }
    });
    __privateWrapper(this, _pendingTransactions)._--;
  }
};
updateCache_fn = async function(fn) {
  if (__privateGet5(this, _cacheLock)) {
    await __privateGet5(this, _cacheLock);
  }
  __privateSet4(this, _cacheLock, (fn == null ? void 0 : fn().then(
    () => {
      __privateSet4(this, _cacheLock, null);
    },
    () => {
    }
  )) ?? null);
};
waitForLastDigest_fn = async function() {
  const digest = __privateGet5(this, _lastDigest2);
  if (digest) {
    __privateSet4(this, _lastDigest2, null);
    await __privateGet5(this, _client2).waitForTransaction({ digest });
  }
};
getGasCoin_fn = async function() {
  if (__privateGet5(this, _coinPool).length === 0 && __privateGet5(this, _pendingTransactions) <= __privateGet5(this, _maxPoolSize)) {
    await __privateMethod(this, _ParallelTransactionExecutor_instances, refillCoinPool_fn).call(this);
  }
  if (__privateGet5(this, _coinPool).length === 0) {
    throw new Error("No coins available");
  }
  const coin = __privateGet5(this, _coinPool).shift();
  return coin;
};
getGasPrice_fn = async function() {
  const remaining = __privateGet5(this, _gasPrice) ? __privateGet5(this, _gasPrice).expiration - __privateGet5(this, _epochBoundaryWindow) - Date.now() : 0;
  if (remaining > 0) {
    return __privateGet5(this, _gasPrice).price;
  }
  if (__privateGet5(this, _gasPrice)) {
    const timeToNextEpoch = Math.max(
      __privateGet5(this, _gasPrice).expiration + __privateGet5(this, _epochBoundaryWindow) - Date.now(),
      1e3
    );
    await new Promise((resolve) => setTimeout(resolve, timeToNextEpoch));
  }
  const state = await __privateGet5(this, _client2).getLatestSuiSystemState();
  __privateSet4(this, _gasPrice, {
    price: BigInt(state.referenceGasPrice),
    expiration: Number.parseInt(state.epochStartTimestampMs, 10) + Number.parseInt(state.epochDurationMs, 10)
  });
  return __privateMethod(this, _ParallelTransactionExecutor_instances, getGasPrice_fn).call(this);
};
refillCoinPool_fn = async function() {
  var _a;
  const batchSize = Math.min(
    __privateGet5(this, _coinBatchSize),
    __privateGet5(this, _maxPoolSize) - (__privateGet5(this, _coinPool).length + __privateGet5(this, _pendingTransactions)) + 1
  );
  if (batchSize === 0) {
    return;
  }
  const txb = new Transaction();
  const address = __privateGet5(this, _signer2).toSuiAddress();
  txb.setSender(address);
  if (__privateGet5(this, _sourceCoins)) {
    const refs = [];
    const ids = [];
    for (const [id, ref] of __privateGet5(this, _sourceCoins)) {
      if (ref) {
        refs.push(ref);
      } else {
        ids.push(id);
      }
    }
    if (ids.length > 0) {
      const coins = await __privateGet5(this, _client2).multiGetObjects({
        ids
      });
      refs.push(
        ...coins.filter((coin) => coin.data !== null).map(({ data }) => ({
          objectId: data.objectId,
          version: data.version,
          digest: data.digest
        }))
      );
    }
    txb.setGasPayment(refs);
    __privateSet4(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const amounts = new Array(batchSize).fill(__privateGet5(this, _initialCoinBalance));
  const results = txb.splitCoins(txb.gas, amounts);
  const coinResults = [];
  for (let i = 0; i < amounts.length; i++) {
    coinResults.push(results[i]);
  }
  txb.transferObjects(coinResults, address);
  await this.waitForLastTransaction();
  const result = await __privateGet5(this, _client2).signAndExecuteTransaction({
    transaction: txb,
    signer: __privateGet5(this, _signer2),
    options: {
      showRawEffects: true
    }
  });
  const effects = suiBcs.TransactionEffects.parse(Uint8Array.from(result.rawEffects));
  (_a = effects.V2) == null ? void 0 : _a.changedObjects.forEach(([id, { outputState }], i) => {
    var _a2;
    if (i === ((_a2 = effects.V2) == null ? void 0 : _a2.gasObjectIndex) || !outputState.ObjectWrite) {
      return;
    }
    __privateGet5(this, _coinPool).push({
      id,
      version: effects.V2.lamportVersion,
      digest: outputState.ObjectWrite[0],
      balance: BigInt(__privateGet5(this, _initialCoinBalance))
    });
  });
  if (!__privateGet5(this, _sourceCoins)) {
    __privateSet4(this, _sourceCoins, /* @__PURE__ */ new Map());
  }
  const gasObject = getGasCoinFromEffects(effects).ref;
  __privateGet5(this, _sourceCoins).set(gasObject.objectId, gasObject);
  await __privateGet5(this, _client2).waitForTransaction({ digest: result.digest });
};

// node_modules/@mysten/sui/dist/esm/transactions/intents/CoinWithBalance.js
var COIN_WITH_BALANCE = "CoinWithBalance";
var SUI_TYPE = normalizeStructTag("0x2::sui::SUI");
function coinWithBalance({
  type = SUI_TYPE,
  balance,
  useGasCoin = true
}) {
  let coinResult = null;
  return (tx) => {
    if (coinResult) {
      return coinResult;
    }
    tx.addIntentResolver(COIN_WITH_BALANCE, resolveCoinBalance);
    const coinType = type === "gas" ? type : normalizeStructTag(type);
    coinResult = tx.add(
      Commands.Intent({
        name: COIN_WITH_BALANCE,
        inputs: {},
        data: {
          type: coinType === SUI_TYPE && useGasCoin ? "gas" : coinType,
          balance: BigInt(balance)
        }
      })
    );
    return coinResult;
  };
}
var CoinWithBalanceData = object({
  type: string(),
  balance: bigint()
});
async function resolveCoinBalance(transactionData, buildOptions, next) {
  var _a, _b;
  const coinTypes = /* @__PURE__ */ new Set();
  const totalByType = /* @__PURE__ */ new Map();
  if (!transactionData.sender) {
    throw new Error("Sender must be set to resolve CoinWithBalance");
  }
  for (const command of transactionData.commands) {
    if (command.$kind === "$Intent" && command.$Intent.name === COIN_WITH_BALANCE) {
      const { type, balance } = parse(CoinWithBalanceData, command.$Intent.data);
      if (type !== "gas" && balance > 0n) {
        coinTypes.add(type);
      }
      totalByType.set(type, (totalByType.get(type) ?? 0n) + balance);
    }
  }
  const usedIds = /* @__PURE__ */ new Set();
  for (const input of transactionData.inputs) {
    if ((_a = input.Object) == null ? void 0 : _a.ImmOrOwnedObject) {
      usedIds.add(input.Object.ImmOrOwnedObject.objectId);
    }
    if ((_b = input.UnresolvedObject) == null ? void 0 : _b.objectId) {
      usedIds.add(input.UnresolvedObject.objectId);
    }
  }
  const coinsByType = /* @__PURE__ */ new Map();
  const client = getSuiClient(buildOptions);
  await Promise.all(
    [...coinTypes].map(async (coinType) => {
      coinsByType.set(
        coinType,
        await getCoinsOfType({
          coinType,
          balance: totalByType.get(coinType),
          client,
          owner: transactionData.sender,
          usedIds
        })
      );
    })
  );
  const mergedCoins = /* @__PURE__ */ new Map();
  mergedCoins.set("gas", { $kind: "GasCoin", GasCoin: true });
  for (const [index, transaction] of transactionData.commands.entries()) {
    if (transaction.$kind !== "$Intent" || transaction.$Intent.name !== COIN_WITH_BALANCE) {
      continue;
    }
    const { type, balance } = transaction.$Intent.data;
    if (balance === 0n && type !== "gas") {
      transactionData.replaceCommand(
        index,
        Commands.MoveCall({ target: "0x2::coin::zero", typeArguments: [type] })
      );
      continue;
    }
    const commands = [];
    if (!mergedCoins.has(type)) {
      const [first, ...rest] = coinsByType.get(type).map(
        (coin) => transactionData.addInput(
          "object",
          Inputs.ObjectRef({
            objectId: coin.coinObjectId,
            digest: coin.digest,
            version: coin.version
          })
        )
      );
      if (rest.length > 0) {
        commands.push(Commands.MergeCoins(first, rest));
      }
      mergedCoins.set(type, first);
    }
    commands.push(
      Commands.SplitCoins(mergedCoins.get(type), [
        transactionData.addInput("pure", Inputs.Pure(suiBcs.u64().serialize(balance)))
      ])
    );
    transactionData.replaceCommand(index, commands);
    transactionData.mapArguments((arg) => {
      if (arg.$kind === "Result" && arg.Result === index) {
        return {
          $kind: "NestedResult",
          NestedResult: [index + commands.length - 1, 0]
        };
      }
      return arg;
    });
  }
  return next();
}
async function getCoinsOfType({
  coinType,
  balance,
  client,
  owner,
  usedIds
}) {
  let remainingBalance = balance;
  const coins = [];
  return loadMoreCoins();
  async function loadMoreCoins(cursor = null) {
    const { data, hasNextPage, nextCursor } = await client.getCoins({ owner, coinType, cursor });
    const sortedCoins = data.sort((a, b) => Number(BigInt(b.balance) - BigInt(a.balance)));
    for (const coin of sortedCoins) {
      if (usedIds.has(coin.coinObjectId)) {
        continue;
      }
      const coinBalance = BigInt(coin.balance);
      coins.push(coin);
      remainingBalance -= coinBalance;
      if (remainingBalance <= 0) {
        return coins;
      }
    }
    if (hasNextPage) {
      return loadMoreCoins(nextCursor);
    }
    throw new Error(`Not enough coins of type ${coinType} to satisfy requested balance`);
  }
}
function getSuiClient(options) {
  const client = getClient(options);
  if (!client.jsonRpc) {
    throw new Error(`CoinWithBalance intent currently only works with SuiClient`);
  }
  return client;
}

// node_modules/@mysten/sui/dist/esm/transactions/Arguments.js
var Arguments = {
  pure: createPure((value) => (tx) => tx.pure(value)),
  object: createObjectMethods((value) => (tx) => tx.object(value)),
  sharedObjectRef: (...args) => (tx) => tx.sharedObjectRef(...args),
  objectRef: (...args) => (tx) => tx.objectRef(...args),
  receivingRef: (...args) => (tx) => tx.receivingRef(...args)
};
export {
  Arguments,
  AsyncCache,
  Commands,
  Inputs,
  ObjectCache,
  ParallelTransactionExecutor,
  SerialTransactionExecutor,
  Transaction,
  TransactionDataBuilder,
  UpgradePolicy,
  coinWithBalance,
  getPureBcsSchema,
  isArgument,
  isTransaction,
  namedPackagesPlugin,
  normalizedTypeToMoveTypeSignature
};
//# sourceMappingURL=@mysten_sui_transactions.js.map
